#!/usr/bin/env python3

"""
Generate an nginx include with manual 301 redirects from Jekyll front-matter.

Usage:
  python make_manual_redirects.py /Users/fairbrot/Documents/igsr/gca_1000genomes_website \
      --out /Users/fairbrot/Documents/igsr/gca_1000genomes_website/docker/manual_redirects.server.conf
  # or print to stdout:
  python make_manual_redirects.py /path/to/gca_1000genomes_website
"""

from __future__ import annotations
import argparse
from pathlib import Path
import re
import sys

MD_EXTS = {".md", ".markdown"}

def iter_md_files(root: Path):
    for p in root.rglob("*"):
        if p.is_file() and p.suffix.lower() in MD_EXTS:
            yield p

FM_START = re.compile(r"^\s*---\s*$")
FM_KEYVAL = re.compile(r"^\s*([A-Za-z0-9_]+)\s*:\s*(.*?)\s*$")
FM_LIST_ITEM = re.compile(r"^\s*-\s*(.*?)\s*$")

def parse_front_matter(p: Path) -> dict:
    """
    Minimal front-matter parser:
      - finds the first '---' block at the top
      - extracts `permalink:` single value
      - extracts `redirect_from:` list items
    Returns: {'permalink': str|None, 'redirect_from': [str, ...]}
    """
    out = {"permalink": None, "redirect_from": []}
    try:
        lines = p.read_text(encoding="utf-8").splitlines()
    except Exception:
        return out

    if not lines or not FM_START.match(lines[0]):
        return out

    # end of first front-matter block
    end = None
    for i in range(1, len(lines)):
        if FM_START.match(lines[i]):
            end = i
            break
    if end is None:
        return out

    in_redirects = False
    for line in lines[1:end]:
        if in_redirects:
            m_item = FM_LIST_ITEM.match(line)
            if m_item:
                v = _clean_url(m_item.group(1))
                if v:
                    out["redirect_from"].append(v)
                continue
            # left the list if indentation/key changed
            in_redirects = False

        m = FM_KEYVAL.match(line)
        if not m:
            continue
        key, raw = m.group(1), m.group(2)
        key = key.strip()

        if key == "permalink":
            val = _clean_url(_strip_quotes(raw))
            if val:
                out["permalink"] = _ensure_dir_url(val)
        elif key == "redirect_from":
            in_redirects = True  # subsequent '- ' lines are items

    return out

def _strip_quotes(s: str) -> str:
    s = s.strip()
    if (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):
        return s[1:-1]
    return s

def _clean_url(s: str) -> str:
    """Normalise a URL path: ensure leading '/', drop query/fragment."""
    s = _strip_quotes(s).strip()
    if not s:
        return ""
    s = s.split("?", 1)[0].split("#", 1)[0]
    if not s.startswith("/"):
        s = "/" + s
    return s

def _ensure_dir_url(s: str) -> str:
    """Ensure trailing slash for directory-style paths (no file extension)."""
    if "." not in Path(s).name and not s.endswith("/"):
        return s + "/"
    return s

def _encode_spaces(path: str) -> str:
    """Percent-encode whitespace for nginx location/return lines."""
    return re.sub(r"\s", "%20", path)

def guess_destination(md_path: Path, permalink: str | None) -> str:
    if permalink:
        return permalink
    stem = md_path.stem
    # heuristic: files under _faq â†’ /faq/<stem>/
    if any(part == "_faq" for part in md_path.parts):
        dest = f"/faq/{stem}/"
    else:
        dest = f"/{stem}/"
    return _ensure_dir_url(dest)

def main():
    ap = argparse.ArgumentParser(description="Emit nginx manual redirects from Jekyll front-matter.")
    ap.add_argument("root", type=Path, help="Path to Jekyll site root (where _faq/, etc. live)")
    ap.add_argument("--out", type=Path, help="Write to file instead of stdout")
    args = ap.parse_args()

    root: Path = args.root.resolve()
    if not root.exists():
        sys.exit(f"Root not found: {root}")

    pairs: list[tuple[str, str]] = []  # (src, dest)

    for md in iter_md_files(root):
        meta = parse_front_matter(md)
        if not meta["redirect_from"]:
            continue
        dest = guess_destination(md, meta["permalink"])
        for src in meta["redirect_from"]:
            # produce both /old and /old/
            src_noslash = src.rstrip("/")
            src_slash = src_noslash + "/"
            pairs.append((src_noslash, dest))
            pairs.append((src_slash, dest))

    # de-dup while preserving order
    seen = set()
    unique = []
    for pair in pairs:
        if pair in seen:
            continue
        seen.add(pair)
        unique.append(pair)

    lines = ["# autogenerated by make_manual_redirects.py"]
    for src, dest in unique:
        src_enc = _encode_spaces(src)
        dest_enc = _encode_spaces(dest)
        # preserve query strings from the client via $is_args$args
        lines.append(f"location = {src_enc} {{ return 301 {dest_enc}$is_args$args; }}")

    text = "\n".join(lines) + "\n"

    if args.out:
        args.out.write_text(text, encoding="utf-8")
        print(f"Wrote {args.out}")
    else:
        print(text, end="")

if __name__ == "__main__":
    main()